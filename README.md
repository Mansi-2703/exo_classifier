Steps to execute:
pip install -r requirements.txt
python app.py

Overview
This project presents an AI/ML-powered system designed to automatically identify and analyze exoplanets from NASA’s open datasets. Using data from the Kepler and TESS missions, our model classifies celestial objects as habitable or non-habitable while providing insightful visualizations through an interactive web interface.

The tool enables users to upload new data, view total detected planets, candidate exoplanets, and potentially habitable worlds. It also retrains the model dynamically and displays accuracy statistics and interpretability metrics.

1. Brainstorming & Planning
Our goal was to combine scientific accuracy with an intuitive interface.
Key steps:
A. Selected Kepler and TESS datasets.
B. Identified crucial planetary and stellar features.
C. Planned clear visualizations for scientific and public understanding.
D. Finalized workflow and chosen tech stack (Python ML + Flask).

2. Dataset Cleaning & Feature Selection
Datasets
Kepler Objects of Interest (KOI)
TESS Objects of Interest (TOI)

Preprocessing
Removed missing/inconsistent entries.
Normalized numeric values.
Encoded “disposition” labels for classification.
Removed redundant or highly correlated features.

Feature Selected:
disposition
orbital_period_days
transit_duration_hours
transit_depth_ppm
planetary_radius_earth_radii
insolation_flux_earth_flux
equilibrium_temperature_k
stellar_effective_temperature_k
stellar_surface_gravity_log10_cm_s2
stellar_radius_solar_radii
right_ascension_decimal_degrees
declination_decimal_degrees

3. Visualizations

Our project includes several powerful visualizations designed to make exoplanet data exploration and model interpretability intuitive and engaging.

A. Goldilocks Zone Plot (Habitable Zone Visualizer): Displays whether a planet lies inside, outside, or near the habitable zone based on its stellar and orbital properties.
B. Orbit Map (Star–Planet System Viewer): Provides an interactive circular visualization showing orbital distances from stars, with colors representing habitability status.
C. Feature Importance Constellation: A radial or constellation-style chart that highlights which features most influence the model’s predictions.
D. Planetary Profile Dashboard: A radar (spider) chart comparing each planet’s parameters—such as radius, tempertaure, insolation flux, orbital period—with Earth or a habitable baseline.
E. Feature Pair Explorer: Allows interactive exploration of relationships between any two features through scatter plots.
F. Prediction Explainability (SHAP Visualization): Uses SHAP force and waterfall plots to explain why the model classified a planet as habitable or non-habitable.
G. Galactic Map View: Projects discovered planets onto galactic coordinates (Right Ascension and Declination), color-coded by their habitability class.

4. Approach & Workflow
A. Dataset Collection – Merged NASA’s Kepler and TESS datasets.
B. Data Cleaning – Handled missing values, normalized and aligned key features.
C. Feature Engineering – Prepared the data for machine learning.
D. Model Training & Validation – Trained XGBoost and validated performance(86% accuracy).
E. Integration & Deployment – Connected the model to a Flask backend and deployed with Gunicorn.

5. Tech Stack Used
A. Backend: The backend was developed using Flask (Python), which manages API endpoints and serves predictions generated by the trained machine learning model.
B. Frontend: A responsive interface was built using HTML, CSS, and JavaScript, providing users with an interactive and visually appealing experience for uploading data and exploring results.
C. Machine Learning: The classification model is based on a Random Forest algorithm, stored as a .pkl file for efficient loading and real-time predictions.
D. Machine Learning Libraries: Scikit-learn was used for model training, evaluation, and preprocessing, while Pandas and NumPy handled data cleaning, merging, and feature engineering.
E. Visualization Tools: Visualization components were created with Plotly, Seaborn, Matplotlib, and SHAP, enabling dynamic and explanatory charts within the web app.
F. Deployment: The system is deployed using Render, which serves the Flask app in a production environment, ensuring performance and reliability.
G. Version Control: Git and GitHub were used for collaborative development, version tracking, and repository management throughout the hackathon.